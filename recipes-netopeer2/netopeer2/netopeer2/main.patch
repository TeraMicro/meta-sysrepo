diff -urN netopeer2/src/Changes netopeer2-working/src/Changes
--- netopeer2/src/Changes	1970-01-01 05:30:00.000000000 +0530
+++ netopeer2-working/src/Changes	2024-02-10 15:29:15.689402995 +0530
@@ -0,0 +1,352 @@
+https://github.com/CESNET/netopeer2/issues/658
+
+Create a new .xml file and give it a name like "config-acm.xml". Write the following contents and save:
+<nacm xmlns="urn:ietf:params:xml:ns:yang:ietf-netconf-acm">
+     <enable-nacm>false</enable-nacm>
+</nacm>
+Load the created file into the sysrepo datastore via following commands:
+sysrepocfg --import=config-acm.xml --datastore startup --module ietf-netconf-acm
+
+sysrepocfg --import=config-acm.xml --datastore running --module ietf-netconf-acm
+
+sysrepocfg --import=config-acm.xml --datastore candidate --module ietf-netconf-acm
+
+  <netconf-server xmlns="urn:ietf:params:xml:ns:yang:ietf-netconf-server">
+    <listen>
+      <endpoint>
+        <name>default-ssh</name>
+        <ssh>
+          <tcp-server-parameters>
+            <local-address>0.0.0.0</local-address>
+            <keepalives>
+              <idle-time>1</idle-time>
+              <max-probes>10</max-probes>
+              <probe-interval>5</probe-interval>
+            </keepalives>
+          </tcp-server-parameters>
+          <ssh-server-parameters>
+            <server-identity>
+              <host-key>
+                <name>default-key</name>
+                <public-key>
+                  <keystore-reference>genkey</keystore-reference>
+                </public-key>
+              </host-key>
+            </server-identity>
+            <client-authentication>
+              <supported-authentication-methods>
+                <publickey/>
+                <passsword/>
+              </supported-authentication-methods>
+            </client-authentication>
+          </ssh-server-parameters>
+        </ssh>
+      </endpoint>
+    </listen>
+  </netconf-server>
+
+
+edit-config --target running --config
+<supervision xmlns="urn:o-ran:supervision:1.0">
+    <cu-plane-monitoring>
+      <configured-cu-monitoring-interval>60</configured-cu-monitoring-interval>
+    </cu-plane-monitoring>
+</supervision>
+> get-config --source running --filter-xpath /supervision
+DATA
+<data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
+  <supervision xmlns="urn:o-ran:supervision:1.0">
+    <cu-plane-monitoring>
+      <configured-cu-monitoring-interval>70</configured-cu-monitoring-interval>
+    </cu-plane-monitoring>
+  </supervision>
+</data>
+
+<supervision-watchdog-reset xmlns="urn:o-ran:supervision:1.0">
+    <supervision-notification-interval>60</supervision-notification-interval>
+    <guard-timer-overhead>60</guard-timer-overhead>
+</supervision-watchdog-reset>
+
+get --filter-xpath /ietf-netconf-monitoring:netconf-state
+
+supervision notification not sent
+get --filter
+sysrepo was crashing multiple times, only way was to restart the netopeer2-server
+
+get --filter-xpath /user-plane-configuration
+get-config --source running --filter-xpath /user-plane-configuration
+
+edit-config --target running --config
+<user-plane-configuration xmlns="urn:o-ran:uplane-conf:1.0">
+  <tx-array-carriers>
+    <name>TXA1</name>
+    <center-of-channel-bandwidth>1</center-of-channel-bandwidth>
+    <channel-bandwidth>1</channel-bandwidth>
+    <active>INACTIVE</active>
+    <gain>1</gain>
+    <downlink-radio-frame-offset>1</downlink-radio-frame-offset>
+    <downlink-sfn-offset>1</downlink-sfn-offset>
+  </tx-array-carriers>
+  <tx-array-carriers>
+    <name>TXA2</name>
+    <center-of-channel-bandwidth>1</center-of-channel-bandwidth>
+    <channel-bandwidth>1</channel-bandwidth>
+    <active>INACTIVE</active>
+    <gain>1</gain>
+    <downlink-radio-frame-offset>1</downlink-radio-frame-offset>
+    <downlink-sfn-offset>1</downlink-sfn-offset>
+  </tx-array-carriers>
+  <rx-array-carriers>
+    <name>RXA1</name>
+    <center-of-channel-bandwidth>1</center-of-channel-bandwidth>
+    <channel-bandwidth>1</channel-bandwidth>
+    <active>INACTIVE</active>
+    <downlink-radio-frame-offset>1</downlink-radio-frame-offset>
+    <downlink-sfn-offset>1</downlink-sfn-offset>
+    <gain-correction>1</gain-correction>
+    <n-ta-offset>1</n-ta-offset>
+  </rx-array-carriers>
+  <rx-array-carriers>
+    <name>RXA2</name>
+    <center-of-channel-bandwidth>1</center-of-channel-bandwidth>
+    <channel-bandwidth>1</channel-bandwidth>
+    <active>INACTIVE</active>
+    <downlink-radio-frame-offset>1</downlink-radio-frame-offset>
+    <downlink-sfn-offset>1</downlink-sfn-offset>
+    <gain-correction>1</gain-correction>
+    <n-ta-offset>1</n-ta-offset>
+  </rx-array-carriers>
+</user-plane-configuration>
+
+<user-plane-configuration xmlns="urn:o-ran:uplane-conf:1.0">
+  <low-level-tx-endpoints>
+    <name>STXE0</name>
+    <compression>
+      <iq-bitwidth>9</iq-bitwidth>
+      <compression-type>STATIC</compression-type>
+      <exponent>4</exponent>
+    </compression>
+    <cp-length>1</cp-length>
+    <cp-length-other>1</cp-length-other>
+    <offset-to-absolute-frequency-center>1</offset-to-absolute-frequency-center>
+    <e-axcid>
+      <o-du-port-bitmask>65024</o-du-port-bitmask>
+      <band-sector-bitmask>448</band-sector-bitmask>
+      <ccid-bitmask>56</ccid-bitmask>
+      <ru-port-bitmask>7</ru-port-bitmask>
+      <eaxc-id>8</eaxc-id>
+    </e-axcid>
+  </low-level-tx-endpoints>
+  <low-level-tx-endpoints>
+    <name>STXE1</name>
+    <compression>
+      <iq-bitwidth>9</iq-bitwidth>
+      <compression-type>STATIC</compression-type>
+      <exponent>4</exponent>
+    </compression>
+    <cp-length>1</cp-length>
+    <cp-length-other>1</cp-length-other>
+    <offset-to-absolute-frequency-center>1</offset-to-absolute-frequency-center>
+    <e-axcid>
+      <o-du-port-bitmask>65024</o-du-port-bitmask>
+      <band-sector-bitmask>448</band-sector-bitmask>
+      <ccid-bitmask>56</ccid-bitmask>
+      <ru-port-bitmask>7</ru-port-bitmask>
+      <eaxc-id>8</eaxc-id>
+    </e-axcid>
+  </low-level-tx-endpoints>
+  <low-level-tx-endpoints>
+    <name>STXE2</name>
+    <compression>
+      <iq-bitwidth>9</iq-bitwidth>
+      <compression-type>STATIC</compression-type>
+      <exponent>4</exponent>
+    </compression>
+    <cp-length>1</cp-length>
+    <cp-length-other>1</cp-length-other>
+    <offset-to-absolute-frequency-center>1</offset-to-absolute-frequency-center>
+    <e-axcid>
+      <o-du-port-bitmask>65024</o-du-port-bitmask>
+      <band-sector-bitmask>448</band-sector-bitmask>
+      <ccid-bitmask>56</ccid-bitmask>
+      <ru-port-bitmask>7</ru-port-bitmask>
+      <eaxc-id>8</eaxc-id>
+    </e-axcid>
+  </low-level-tx-endpoints>
+  <low-level-tx-endpoints>
+    <name>STXE3</name>
+    <compression>
+      <iq-bitwidth>9</iq-bitwidth>
+      <compression-type>STATIC</compression-type>
+      <exponent>4</exponent>
+    </compression>
+    <cp-length>1</cp-length>
+    <cp-length-other>1</cp-length-other>
+    <offset-to-absolute-frequency-center>1</offset-to-absolute-frequency-center>
+    <e-axcid>
+      <o-du-port-bitmask>65024</o-du-port-bitmask>
+      <band-sector-bitmask>448</band-sector-bitmask>
+      <ccid-bitmask>56</ccid-bitmask>
+      <ru-port-bitmask>7</ru-port-bitmask>
+      <eaxc-id>8</eaxc-id>
+    </e-axcid>
+  </low-level-tx-endpoints>
+  <low-level-rx-endpoints>
+    <name>SRXE0</name>
+    <compression>
+      <iq-bitwidth>9</iq-bitwidth>
+      <compression-type>STATIC</compression-type>
+      <exponent>4</exponent>
+    </compression>
+    <cp-length>1</cp-length>
+    <cp-length-other>1</cp-length-other>
+    <offset-to-absolute-frequency-center>1</offset-to-absolute-frequency-center>
+    <e-axcid>
+      <o-du-port-bitmask>65024</o-du-port-bitmask>
+      <band-sector-bitmask>448</band-sector-bitmask>
+      <ccid-bitmask>56</ccid-bitmask>
+      <ru-port-bitmask>7</ru-port-bitmask>
+      <eaxc-id>8</eaxc-id>
+    </e-axcid>
+  </low-level-rx-endpoints>
+  <low-level-rx-endpoints>
+    <name>SRXE1</name>
+    <compression>
+      <iq-bitwidth>9</iq-bitwidth>
+      <compression-type>STATIC</compression-type>
+      <exponent>4</exponent>
+    </compression>
+    <cp-length>1</cp-length>
+    <cp-length-other>1</cp-length-other>
+    <offset-to-absolute-frequency-center>1</offset-to-absolute-frequency-center>
+    <e-axcid>
+      <o-du-port-bitmask>65024</o-du-port-bitmask>
+      <band-sector-bitmask>448</band-sector-bitmask>
+      <ccid-bitmask>56</ccid-bitmask>
+      <ru-port-bitmask>7</ru-port-bitmask>
+      <eaxc-id>8</eaxc-id>
+    </e-axcid>
+  </low-level-rx-endpoints>
+  <low-level-rx-endpoints>
+    <name>SRXE2</name>
+    <compression>
+      <iq-bitwidth>9</iq-bitwidth>
+      <compression-type>STATIC</compression-type>
+      <exponent>4</exponent>
+    </compression>
+    <cp-length>1</cp-length>
+    <cp-length-other>1</cp-length-other>
+    <offset-to-absolute-frequency-center>1</offset-to-absolute-frequency-center>
+    <e-axcid>
+      <o-du-port-bitmask>65024</o-du-port-bitmask>
+      <band-sector-bitmask>448</band-sector-bitmask>
+      <ccid-bitmask>56</ccid-bitmask>
+      <ru-port-bitmask>7</ru-port-bitmask>
+      <eaxc-id>8</eaxc-id>
+    </e-axcid>
+  </low-level-rx-endpoints>
+  <low-level-rx-endpoints>
+    <name>SRXE3</name>
+    <compression>
+      <iq-bitwidth>9</iq-bitwidth>
+      <compression-type>STATIC</compression-type>
+      <exponent>4</exponent>
+    </compression>
+    <cp-length>1</cp-length>
+    <cp-length-other>1</cp-length-other>
+    <offset-to-absolute-frequency-center>1</offset-to-absolute-frequency-center>
+    <e-axcid>
+      <o-du-port-bitmask>65024</o-du-port-bitmask>
+      <band-sector-bitmask>448</band-sector-bitmask>
+      <ccid-bitmask>56</ccid-bitmask>
+      <ru-port-bitmask>7</ru-port-bitmask>
+      <eaxc-id>8</eaxc-id>
+    </e-axcid>
+  </low-level-rx-endpoints>
+</user-plane-configuration>
+
+<interfaces xmlns="urn:ietf:params:xml:ns:yang:ietf-interfaces" xmlns:o-ran-int="urn:o-ran:interfaces:1.0"
+  xmlns:ianaift="urn:ietf:params:xml:ns:yang:iana-if-type">
+  <interface>
+    <name>ETH1</name>
+    <type>ianaift:l2vlan</type>
+    <o-ran-int:vlan-id>500</o-ran-int:vlan-id>
+    <o-ran-int:mac-address>00:1A:2B:3C:4D:5E</o-ran-int:mac-address>
+  </interface>
+</interfaces>
+
+<processing-elements xmlns="urn:o-ran:processing-element:1.0">
+  <ru-elements>
+    <name>PE1</name>
+      <transport-flow>
+        <interface-name>ETH1</interface-name>
+          <eth-flow>
+            <ru-mac-address>00:1A:2B:3C:4D:5E</ru-mac-address>
+            <vlan-id>500</vlan-id>
+            <o-du-mac-address>00:1A:2B:3C:4D:5F</o-du-mac-address>
+          </eth-flow>
+      </transport-flow>
+  </ru-elements>
+</processing-elements>
+
+<user-plane-configuration xmlns="urn:o-ran:uplane-conf:1.0">
+  <low-level-tx-links>
+    <name>LLTL0</name>
+    <processing-element>PE1</processing-element>
+    <tx-array-carrier>TXA1</tx-array-carrier>
+    <low-level-tx-endpoint>STXE0</low-level-tx-endpoint>
+  </low-level-tx-links>
+  <low-level-tx-links>
+    <name>LLTL1</name>
+    <processing-element>PE1</processing-element>
+    <tx-array-carrier>TXA1</tx-array-carrier>
+    <low-level-tx-endpoint>STXE1</low-level-tx-endpoint>
+  </low-level-tx-links>
+  <low-level-tx-links>
+    <name>LLTL2</name>
+    <processing-element>PE1</processing-element>
+    <tx-array-carrier>TXA1</tx-array-carrier>
+    <low-level-tx-endpoint>STXE2</low-level-tx-endpoint>
+  </low-level-tx-links>
+  <low-level-tx-links>
+    <name>LLTL3</name>
+    <processing-element>PE1</processing-element>
+    <tx-array-carrier>TXA1</tx-array-carrier>
+    <low-level-tx-endpoint>STXE3</low-level-tx-endpoint>
+  </low-level-tx-links>
+  <low-level-rx-links>
+    <name>LLRL0</name>
+    <processing-element>PE1</processing-element>
+    <rx-array-carrier>RXA1</rx-array-carrier>
+    <low-level-rx-endpoint>SRXE0</low-level-rx-endpoint>
+  </low-level-rx-links>
+  <low-level-rx-links>
+    <name>LLRL1</name>
+    <processing-element>PE1</processing-element>
+    <rx-array-carrier>RXA1</rx-array-carrier>
+    <low-level-rx-endpoint>SRXE1</low-level-rx-endpoint>
+  </low-level-rx-links>
+  <low-level-rx-links>
+    <name>LLRL2</name>
+    <processing-element>PE1</processing-element>
+    <rx-array-carrier>RXA1</rx-array-carrier>
+    <low-level-rx-endpoint>SRXE2</low-level-rx-endpoint>
+  </low-level-rx-links>
+  <low-level-rx-links>
+    <name>LLRL3</name>
+    <processing-element>PE1</processing-element>
+    <rx-array-carrier>RXA1</rx-array-carrier>
+    <low-level-rx-endpoint>SRXE3</low-level-rx-endpoint>
+  </low-level-rx-links>
+</user-plane-configuration>
+
+<user-plane-configuration xmlns="urn:o-ran:uplane-conf:1.0">
+  <tx-array-carriers>
+    <name>TXA1</name>
+    <active>ACTIVE</active>
+  </tx-array-carriers>
+  <rx-array-carriers>
+    <name>RXA1</name>
+    <active>ACTIVE</active>
+  </rx-array-carriers>
+</user-plane-configuration>
\ No newline at end of file
diff -urN netopeer2/src/main.c netopeer2-working/src/main.c
--- netopeer2/src/main.c	2024-02-09 22:04:05.417091654 +0530
+++ netopeer2-working/src/main.c	2024-02-10 13:37:23.324273161 +0530
@@ -726,6 +726,303 @@
     return SR_ERR_OK;
 }
 
+static int
+supervision_cb(sr_session_ctx_t *UNUSED(session), uint32_t UNUSED(sub_id), const char *UNUSED(xpath),
+        const sr_val_t *input, const size_t input_cnt, sr_event_t UNUSED(event), uint32_t UNUSED(request_id),
+        sr_val_t **output, size_t *output_cnt, void *UNUSED(private_data))
+{
+    ERR("supervision_cb callback\n");
+    // Check if there are input parameters
+    if (input == NULL || input_cnt == 0) {
+        fprintf(stderr, "No input parameters received for RPC\n");
+        return SR_ERR_INVAL_ARG; // or handle it according to your requirements
+    }
+    ERR("input_cnt %d\n", input_cnt);
+    // Process each input parameter
+    for (size_t i = 0; i < input_cnt; ++i) {
+        const char *param_name = input[i].xpath;
+        const sr_val_t *param_value = &input[i];
+        // Process the input parameter based on its name and value
+        if (strcmp(param_name, "/o-ran-supervision:supervision-watchdog-reset/supervision-notification-interval") == 0) {
+            // Example: Extract uint16_t value
+            uint16_t notification_interval = param_value->data.uint16_val;
+            printf("Received supervision-notification-interval: %u\n", notification_interval);
+        } else if (strcmp(param_name, "/o-ran-supervision:supervision-watchdog-reset/guard-timer-overhead") == 0) {
+            // Example: Extract uint16_t value
+            uint16_t guard_timer_overhead = param_value->data.uint16_val;
+            printf("Received guard-timer-overhead: %u\n", guard_timer_overhead);
+        }
+        // Add more cases for other input parameters as needed
+    }
+    // TODO: Implement your RPC logic here using the input parameters
+
+    // Example: Set output parameters
+    *output = calloc(1, 1 * sizeof **output);
+    *output_cnt = 1;
+
+    (*output)[0].type = SR_STRING_T;
+    (*output)[0].data.string_val = strdup("2023-12-01T12:00:00+00:00");
+    (*output)[0].xpath = strdup("/o-ran-supervision:supervision-watchdog-reset/next-update-at");
+
+    sr_val_t *input1 = calloc(1, 1 * sizeof(sr_val_t));
+    input1[0].xpath = "/o-ran-supervision:supervision-notification/session-id";
+    input1[0].type = SR_UINT32_T;
+    input1[0].data.uint32_val = 1;
+    const sr_error_info_t *err_info;
+    sr_subscription_ctx_t *subscribe = NULL;
+
+    if(sr_notif_send(np2srv.sr_sess, "/o-ran-supervision:supervision-notification", input1, 1, np2srv.sr_timeout, 0) != SR_ERR_OK)
+    {
+        sr_session_get_error(np2srv.sr_sess, &err_info);
+        ERR("sr_notif_send_tree failed %s\n", err_info->err[0].message);
+    }
+
+    return SR_ERR_OK;
+}
+void
+print_val(const sr_val_t *value)
+{
+    if (NULL == value) {
+        return;
+    }
+
+    printf("Leaf Node %s ", value->xpath);
+
+    switch (value->type) {
+    case SR_CONTAINER_T:
+    case SR_CONTAINER_PRESENCE_T:
+        printf("(container)");
+        break;
+    case SR_LIST_T:
+        printf("(list instance)");
+        break;
+    case SR_STRING_T:
+        printf("= %s", value->data.string_val);
+        break;
+    case SR_BOOL_T:
+        printf("= %s", value->data.bool_val ? "true" : "false");
+        break;
+    case SR_DECIMAL64_T:
+        printf("= %g", value->data.decimal64_val);
+        break;
+    case SR_INT8_T:
+        printf("= %" PRId8, value->data.int8_val);
+        break;
+    case SR_INT16_T:
+        printf("= %" PRId16, value->data.int16_val);
+        break;
+    case SR_INT32_T:
+        printf("= %" PRId32, value->data.int32_val);
+        break;
+    case SR_INT64_T:
+        printf("= %" PRId64, value->data.int64_val);
+        break;
+    case SR_UINT8_T:
+        printf("= %" PRIu8, value->data.uint8_val);
+        break;
+    case SR_UINT16_T:
+        printf("= %" PRIu16, value->data.uint16_val);
+        break;
+    case SR_UINT32_T:
+        printf("= %" PRIu32, value->data.uint32_val);
+        break;
+    case SR_UINT64_T:
+        printf("= %" PRIu64, value->data.uint64_val);
+        break;
+    case SR_IDENTITYREF_T:
+        printf("= %s", value->data.identityref_val);
+        break;
+    case SR_INSTANCEID_T:
+        printf("= %s", value->data.instanceid_val);
+        break;
+    case SR_BITS_T:
+        printf("= %s", value->data.bits_val);
+        break;
+    case SR_BINARY_T:
+        printf("= %s", value->data.binary_val);
+        break;
+    case SR_ENUM_T:
+        printf("= %s", value->data.enum_val);
+        break;
+    case SR_LEAF_EMPTY_T:
+        printf("(empty leaf)");
+        break;
+    default:
+        printf("(unprintable)");
+        break;
+    }
+
+    switch (value->type) {
+    case SR_UNKNOWN_T:
+    case SR_CONTAINER_T:
+    case SR_CONTAINER_PRESENCE_T:
+    case SR_LIST_T:
+    case SR_LEAF_EMPTY_T:
+        printf("\n");
+        break;
+    default:
+        printf("%s\n", value->dflt ? " [default]" : "");
+        break;
+    }
+}
+
+void
+print_change(sr_change_oper_t op, sr_val_t *old_val, sr_val_t *new_val)
+{
+    switch (op) {
+    case SR_OP_CREATED:
+        printf("CREATED: ");
+        print_val(new_val);
+        break;
+    case SR_OP_DELETED:
+        printf("DELETED: ");
+        print_val(old_val);
+        break;
+    case SR_OP_MODIFIED:
+        printf("MODIFIED: ");
+        print_val(old_val);
+        printf("to ");
+        print_val(new_val);
+        break;
+    case SR_OP_MOVED:
+        printf("MOVED: ");
+        print_val(new_val);
+        if (old_val) {
+            printf(" after ");
+            print_val(old_val);
+        } else {
+            printf(" to the beginning\n");
+        }
+        break;
+    }
+}
+
+int
+print_current_config(sr_session_ctx_t *session, const char *module_name)
+{
+    sr_val_t *values = NULL;
+    size_t count = 0;
+    int rc = SR_ERR_OK;
+    char *xpath;
+
+    if (asprintf(&xpath, "/%s:*//.", module_name) == -1) {
+        return SR_ERR_NO_MEMORY;
+    }
+    rc = sr_get_items(session, xpath, 0, 0, &values, &count);
+    free(xpath);
+    if (rc != SR_ERR_OK) {
+        return rc;
+    }
+
+    for (size_t i = 0; i < count; i++) {
+        print_val(&values[i]);
+    }
+    sr_free_values(values, count);
+
+    return rc;
+}
+
+const char *
+ev_to_str(sr_event_t ev)
+{
+    switch (ev) {
+    case SR_EV_CHANGE:
+        return "change";
+    case SR_EV_DONE:
+        return "done";
+    case SR_EV_ABORT:
+    default:
+        return "abort";
+    }
+}
+int
+supervision_change_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, sr_event_t event,
+        uint32_t request_id, void *private_data)
+{
+    sr_change_iter_t *it = NULL;
+    int rc = SR_ERR_OK;
+    char path[512];
+    sr_change_oper_t oper;
+    sr_val_t *old_value = NULL;
+    sr_val_t *new_value = NULL;
+    sr_val_t *values = NULL;
+    size_t val_count = 0;
+
+    (void)sub_id;
+    (void)request_id;
+    (void)private_data;
+#if 0
+    if((rc = sr_get_items(session, "/o-ran-uplane-conf:user-plane-configuration/tx-array-carriers//.", 0, 0, &values, &val_count)) != SR_ERR_OK)
+    {
+        VRB("sr_get_items failed %s %d", sr_strerror(rc), rc);
+        goto cleanup;
+    }
+    VRB("val_count = %d", val_count);
+    print_val(values);
+    for(size_t i = 0; i < val_count; i++)
+    {
+        print_val(&values[i]);
+    }
+    rc = sr_session_switch_ds(session, SR_DS_OPERATIONAL);
+    if (rc != SR_ERR_OK) {
+        ERR("Switch operational failed: %s\n", sr_strerror(rc));
+        goto cleanup;
+    }
+    rc = sr_set_item_str(session, "/o-ran-uplane-conf:user-plane-configuration/tx-array-carriers[name='TXA1']/state", "DISABLED", NULL, 0);
+    if (rc != SR_ERR_OK) {
+        ERR("Set item failed: %s\n", sr_strerror(rc));
+        goto cleanup;
+    }
+    else
+    {
+        ERR("Set item success\n");
+    }
+    sr_set_item_str(session, "/o-ran-uplane-conf:user-plane-configuration/tx-array-carriers[name='TXA1']/duplex-scheme", "TDD", NULL, 0);
+    rc = sr_apply_changes(session, 0);
+    if (rc != SR_ERR_OK) {
+        ERR("Apply changes failed: %s\n", sr_strerror(rc));
+        goto cleanup;
+    }
+    else
+    {
+        ERR("Apply changes success\n");
+    }
+    rc = sr_session_switch_ds(session, SR_DS_RUNNING);
+    if (rc != SR_ERR_OK) {
+        ERR("Switch running failed: %s\n", sr_strerror(rc));
+        goto cleanup;
+    }
+#endif
+    ERR("\n\n ========== EVENT %s CHANGES: ====================================\n\n", ev_to_str(event));
+
+    if (xpath) {
+        sprintf(path, "%s//.", xpath);
+    } else {
+        sprintf(path, "/%s:*//.", module_name);
+    }
+    rc = sr_get_changes_iter(session, path, &it);
+    if (rc != SR_ERR_OK) {
+        goto cleanup;
+    }
+
+    while ((rc = sr_get_change_next(session, it, &oper, &old_value, &new_value)) == SR_ERR_OK) {
+        print_change(oper, old_value, new_value);
+        sr_free_val(old_value);
+        sr_free_val(new_value);
+    }
+
+    ERR("\n ========== END OF CHANGES =======================================");
+
+    if (event == SR_EV_DONE) {
+        ERR("\n\n ========== CONFIG HAS CHANGED, CURRENT RUNNING CONFIG: ==========\n\n");
+        if (print_current_config(session, module_name) != SR_ERR_OK) {
+            goto cleanup;
+        }
+    }
+cleanup:
+    sr_free_change_iter(it);
+    return SR_ERR_OK; 
+}
 #endif
 
 /**
@@ -784,6 +1081,13 @@
     /* one more yang-push RPC */
     SR_RPC_SUBSCR("/ietf-yang-push:resync-subscription", np2srv_rpc_resync_sub_cb, &np2srv.sr_rpc_sub);
 
+    /*Subscribe for supervision RPC*/
+    rc = sr_rpc_subscribe(np2srv.sr_sess, "/o-ran-supervision:supervision-watchdog-reset", supervision_cb, NULL, 0, 0, &np2srv.sr_rpc_sub);
+    if (rc != SR_ERR_OK) { 
+        ERR("Subscribing for \"%s\" RPC failed (%s).", "o-ran-supervision", sr_strerror(rc)); 
+        goto error; 
+    }
+
     return 0;
 
 error:
@@ -963,7 +1267,23 @@
     xpath = "/ietf-truststore:truststore/certificates";
     SR_CONFIG_SUBSCR(mod_name, xpath, np2srv_dummy_cb);
 #endif
-
+    #if 1
+    mod_name = "o-ran-supervision";
+    xpath = "/o-ran-supervision:supervision/cu-plane-monitoring/configured-cu-monitoring-interval";
+    SR_CONFIG_SUBSCR(mod_name, xpath, supervision_change_cb);
+
+    mod_name = "o-ran-uplane-conf";
+    SR_OPER_SUBSCR(mod_name, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays", np2srv_uplane_tx_arrays_oper_cb);
+    SR_OPER_SUBSCR(mod_name, "/o-ran-uplane-conf:user-plane-configuration/rx-arrays", np2srv_uplane_rx_arrays_oper_cb);
+    SR_OPER_SUBSCR(mod_name, "/o-ran-uplane-conf:user-plane-configuration/static-low-level-tx-endpoints", np2srv_uplane_sllte_oper_cb);
+    SR_OPER_SUBSCR(mod_name, "/o-ran-uplane-conf:user-plane-configuration/static-low-level-rx-endpoints", np2srv_uplane_sllre_oper_cb);
+    SR_CONFIG_SUBSCR(mod_name, "/o-ran-uplane-conf:user-plane-configuration/tx-array-carriers", np2srv_uplane_txac_cb);
+    SR_CONFIG_SUBSCR(mod_name, "/o-ran-uplane-conf:user-plane-configuration/rx-array-carriers", np2srv_uplane_rxac_cb);
+    SR_CONFIG_SUBSCR(mod_name, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints", np2srv_uplane_lltxe_cb);
+    SR_CONFIG_SUBSCR(mod_name, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints", np2srv_uplane_llrxe_cb);
+    SR_CONFIG_SUBSCR(mod_name, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-links", np2srv_uplane_llrxl_cb);
+    SR_CONFIG_SUBSCR(mod_name, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-links", np2srv_uplane_llrxl_cb);
+    #endif
     /*
      * ietf-netconf-acm
      */
diff -urN netopeer2/src/netconf_monitoring.c netopeer2-working/src/netconf_monitoring.c
--- netopeer2/src/netconf_monitoring.c	2024-02-09 22:04:05.417091654 +0530
+++ netopeer2-working/src/netconf_monitoring.c	2024-02-10 14:18:25.737496680 +0530
@@ -266,6 +266,686 @@
     }
 }
 
+void print_xml(struct lyd_node *root){
+ERR("############################################################");
+    char *temp;
+    if(lyd_print_mem(&temp, root, LYD_XML, LYD_PRINT_WITHSIBLINGS) != LY_SUCCESS){
+        ERR("lyd_print_mem failed");
+    }
+    else{
+        ERR("%s", temp);
+        free(temp);
+    }
+ERR("############################################################");
+}
+
+char *extract_key(const char *input) {
+    // Find the position of the first single quote
+    const char *start_quote = strchr(input, '\'');
+    if (!start_quote) {
+        fprintf(stderr, "No opening single quote found\n");
+        return NULL;
+    }
+
+    // Find the position of the closing single quote
+    const char *end_quote = strchr(start_quote + 1, '\'');
+    if (!end_quote) {
+        fprintf(stderr, "No closing single quote found\n");
+        return NULL;
+    }
+
+    // Calculate the length of the content inside single quotes
+    size_t content_length = end_quote - start_quote - 1;
+
+    // Allocate memory for the extracted key
+    char *extracted_key = malloc(content_length + 1);
+    if (!extracted_key) {
+        fprintf(stderr, "Memory allocation failed\n");
+        return NULL;
+    }
+
+    // Copy the content between the single quotes
+    strncpy(extracted_key, start_quote + 1, content_length);
+    extracted_key[content_length] = '\0';
+
+    return extracted_key;
+}
+int np2srv_uplane_llrxe_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data)
+{
+    sr_change_iter_t *it = NULL;
+    int rc = SR_ERR_OK;
+    char path[512];
+    sr_change_oper_t oper;
+    sr_val_t *values = NULL;
+    sr_val_t *values_iter = NULL;
+    size_t val_count = 0;
+    char *key;
+    int i;
+
+    (void)sub_id;
+    (void)request_id;
+    (void)private_data;
+
+    rc = sr_get_items(session, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints", 0, 0, &values_iter, &val_count);
+    if(rc != SR_ERR_OK){
+        ERR("sr_get_item failed");
+        return rc;
+    }
+    VRB("val_count = %d", val_count);
+    for( i = 0; i < val_count; i++)
+    {
+        values = &values_iter[i];
+        key = extract_key(values->xpath);
+        VRB("key = %s", key);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints[name='%s']/compression/iq-bitwidth", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("iq-bitwidth = %d", values->data.uint8_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints[name='%s']/compression/compression-type", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("compression-type = %s", values->data.enum_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints[name='%s']/compression/exponent", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("exponent = %d", values->data.uint8_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints[name='%s']/cp-length", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("cp-length = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints[name='%s']/cp-length-other", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("cp-length-other = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints[name='%s']/offset-to-absolute-frequency-center", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("offset-to-absolute-frequency-center = %d", values->data.uint32_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints[name='%s']/e-axcid/o-du-port-bitmask", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("o-du-port-bitmask = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints[name='%s']/e-axcid/band-sector-bitmask", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("band-sector-bitmask = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints[name='%s']/e-axcid/ccid-bitmask", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("ccid-bitmask = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints[name='%s']/e-axcid/ru-port-bitmask", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("ru-port-bitmask = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-endpoints[name='%s']/e-axcid/eaxc-id", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("eaxc-id = %d", values->data.uint16_val);
+    }
+    //TODO sr_free_values(&values, val_count); //free all dynamic allocated memories
+}
+int np2srv_uplane_lltxe_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data)
+{
+    sr_change_iter_t *it = NULL;
+    int rc = SR_ERR_OK;
+    char path[512];
+    sr_change_oper_t oper;
+    sr_val_t *values = NULL;
+    sr_val_t *values_iter = NULL;
+    size_t val_count = 0;
+    char *key;
+    int i;
+
+    (void)sub_id;
+    (void)request_id;
+    (void)private_data;
+
+    rc = sr_get_items(session, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints", 0, 0, &values_iter, &val_count);
+    if(rc != SR_ERR_OK){
+        ERR("sr_get_item failed");
+        return rc;
+    }
+    VRB("val_count = %d", val_count);
+    for( i = 0; i < val_count; i++)
+    {
+        values = &values_iter[i];
+        key = extract_key(values->xpath);
+        VRB("key = %s", key);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints[name='%s']/compression/iq-bitwidth", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("iq-bitwidth = %d", values->data.uint8_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints[name='%s']/compression/compression-type", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("compression-type = %s", values->data.enum_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints[name='%s']/compression/exponent", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("exponent = %d", values->data.uint8_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints[name='%s']/cp-length", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("cp-length = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints[name='%s']/cp-length-other", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("cp-length-other = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints[name='%s']/offset-to-absolute-frequency-center", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("offset-to-absolute-frequency-center = %d", values->data.uint32_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints[name='%s']/e-axcid/o-du-port-bitmask", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("o-du-port-bitmask = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints[name='%s']/e-axcid/band-sector-bitmask", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("band-sector-bitmask = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints[name='%s']/e-axcid/ccid-bitmask", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("ccid-bitmask = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints[name='%s']/e-axcid/ru-port-bitmask", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("ru-port-bitmask = %d", values->data.uint16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-endpoints[name='%s']/e-axcid/eaxc-id", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("eaxc-id = %d", values->data.uint16_val);
+    }
+}
+int np2srv_uplane_llrxl_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data)
+{
+    sr_change_iter_t *it = NULL;
+    int rc = SR_ERR_OK;
+    char path[512];
+    sr_change_oper_t oper;
+    sr_val_t *values = NULL;
+    sr_val_t *values_iter = NULL;
+    size_t val_count = 0;
+    char *key;
+    int i;
+
+    (void)sub_id;
+    (void)request_id;
+    (void)private_data;
+
+    rc = sr_get_items(session, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-links", 0, 0, &values_iter, &val_count);
+    if(rc != SR_ERR_OK){
+        ERR("sr_get_item failed");
+        return rc;
+    }
+    VRB("val_count = %d", val_count);
+    for( i = 0; i < val_count; i++)
+    {
+        values = &values_iter[i];
+        key = extract_key(values->xpath);
+        VRB("key = %s", key);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-links[name='%s']/processing-element", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("processing-element = %s", values->data.string_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-links[name='%s']/rx-array-carrier", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("rx-array-carrier = %s", values->data.string_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-rx-links[name='%s']/low-level-rx-endpoint", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("low-level-rx-endpoint = %s", values->data.string_val);  
+    }
+    return SR_ERR_OK;
+}
+int np2srv_uplane_lltxl_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data)
+{
+    sr_change_iter_t *it = NULL;
+    int rc = SR_ERR_OK;
+    char path[512];
+    sr_change_oper_t oper;
+    sr_val_t *values = NULL;
+    sr_val_t *values_iter = NULL;
+    size_t val_count = 0;
+    char *key;
+    int i;
+
+    (void)sub_id;
+    (void)request_id;
+    (void)private_data;
+
+    rc = sr_get_items(session, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-links", 0, 0, &values_iter, &val_count);
+    if(rc != SR_ERR_OK){
+        ERR("sr_get_item failed");
+        return rc;
+    }
+    VRB("val_count = %d", val_count);
+    for( i = 0; i < val_count; i++)
+    {
+        values = &values_iter[i];
+        key = extract_key(values->xpath);
+        VRB("key = %s", key);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-links[name='%s']/processing-element", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("processing-element = %s", values->data.string_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-links[name='%s']/tx-array-carrier", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("tx-array-carrier = %s", values->data.string_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/low-level-tx-links[name='%s']/low-level-tx-endpoint", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("low-level-tx-endpoint = %s", values->data.string_val);  
+    }
+    return SR_ERR_OK;
+}
+struct tx_array_carrier{
+    char name[128];
+    char centOfChBdw[128];
+    char active[128];
+    char gain[128];
+    char dwnLkSFNOff[128];
+}txac;
+int np2srv_uplane_rxac_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data)
+{
+    sr_change_iter_t *it = NULL;
+    int rc = SR_ERR_OK;
+    char path[512];
+    sr_change_oper_t oper;
+    sr_val_t *values = NULL;
+    sr_val_t *values_iter = NULL;
+    size_t val_count = 0;
+    char *key;
+    int i;
+
+    (void)sub_id;
+    (void)request_id;
+    (void)private_data;
+
+    rc = sr_get_items(session, "/o-ran-uplane-conf:user-plane-configuration/rx-array-carriers", 0, 0, &values_iter, &val_count);
+    if(rc != SR_ERR_OK){
+        ERR("sr_get_item failed");
+        return rc;
+    }
+    for( i = 0; i < val_count; i++)
+    {
+        values = &values_iter[i];
+        VRB("values->xpath = %s", values->xpath);
+        VRB("values->type = %d", values->type);
+        key = extract_key(values->xpath);
+        VRB("key = %s", key);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/rx-array-carriers[name='%s']/center-of-channel-bandwidth", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("values->type = %d", values->type);
+        VRB("center-of-channel-bandwidth = %ld", values->data.uint64_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/rx-array-carriers[name='%s']/channel-bandwidth", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("channel-bandwidth = %ld", values->data.uint64_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/rx-array-carriers[name='%s']/active", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("values->data.enum_val = %s", values->data.enum_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/rx-array-carriers[name='%s']/downlink-radio-frame-offset", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("downlink-radio-frame-offset = %d", values->data.uint32_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/rx-array-carriers[name='%s']/downlink-sfn-offset", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("downlink-sfn-offset = %d", values->data.int16_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/rx-array-carriers[name='%s']/gain-correction", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("gain-correction = %f", values->data.decimal64_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/rx-array-carriers[name='%s']/n-ta-offset", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("n-ta-offset = %d", values->data.uint32_val);
+        //VRB("values->type = %d", values->type);
+        free(key);
+    }
+    return SR_ERR_OK; 
+}
+int np2srv_uplane_txac_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data)
+{
+    sr_change_iter_t *it = NULL;
+    int rc = SR_ERR_OK;
+    char path[512];
+    sr_change_oper_t oper;
+    sr_val_t *values = NULL;
+    sr_val_t *values_iter = NULL;
+    size_t val_count = 0;
+    char *key;
+    int i;
+
+    (void)sub_id;
+    (void)request_id;
+    (void)private_data;
+
+    rc = sr_get_items(session, "/o-ran-uplane-conf:user-plane-configuration/tx-array-carriers", 0, 0, &values_iter, &val_count);
+    if(rc != SR_ERR_OK){
+        ERR("sr_get_item failed");
+        return rc;
+    }
+    for( i = 0; i < val_count; i++)
+    {
+        values = &values_iter[i];
+        VRB("values->xpath = %s", values->xpath);
+        VRB("values->type = %d", values->type);
+        key = extract_key(values->xpath);
+        VRB("key = %s", key);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/tx-array-carriers[name='%s']/center-of-channel-bandwidth", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("values->type = %d", values->type);
+        VRB("center-of-channel-bandwidth = %ld", values->data.uint64_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/tx-array-carriers[name='%s']/channel-bandwidth", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("channel-bandwidth = %ld", values->data.uint64_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/tx-array-carriers[name='%s']/active", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("values->data.enum_val = %s", values->data.enum_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/tx-array-carriers[name='%s']/gain", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("gain = %f", values->data.decimal64_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/tx-array-carriers[name='%s']/downlink-radio-frame-offset", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("downlink-radio-frame-offset = %d", values->data.uint32_val);
+        sprintf(path, "/o-ran-uplane-conf:user-plane-configuration/tx-array-carriers[name='%s']/downlink-sfn-offset", key);
+        sr_get_item(session, path, 0, &values);
+        VRB("downlink-sfn-offset = %d", values->data.int16_val);
+        //VRB("values->type = %d", values->type);
+        free(key);
+    }
+    return SR_ERR_OK; 
+}
+int
+np2srv_uplane_sllre_oper_cb(sr_session_ctx_t *session, uint32_t UNUSED(sub_id), const char *UNUSED(module_name),
+        const char *UNUSED(path), const char *UNUSED(request_xpath), uint32_t UNUSED(request_id),
+        struct lyd_node **parent, void *UNUSED(private_data))
+{
+    struct lyd_node *root = NULL, *list1,  *list2;
+    const struct lys_module *mod;
+    sr_conn_ctx_t *conn;
+    struct ly_ctx *ly_ctx;
+    char **cpblts;
+    char *time_str, buf[32];
+    uint32_t i;
+
+    /* context is locked while the callback is executed */
+    conn = sr_session_get_connection(session);
+    ly_ctx = (struct ly_ctx *)sr_acquire_context(conn);
+    sr_release_context(conn);
+
+    if(lyd_new_path(NULL, ly_ctx, "/o-ran-uplane-conf:user-plane-configuration", NULL, 0, &root))
+    {
+        goto error;
+    }
+    for( i = 0; i < 4; i++)
+    {
+        sprintf(buf, "SRXE%d", i);
+        if(lyd_new_list(root, NULL, "static-low-level-rx-endpoints", 0, &list1, buf) == LY_SUCCESS)
+        {
+            VRB("lyd_new_list success");
+        }
+        else{
+            VRB("lyd_new_list failed -- %s", ly_errmsg(ly_ctx));
+            goto error;
+        }
+        lyd_new_term(list1, NULL, "restricted-interfaces", "ETH1", 0, NULL);
+        sprintf( buf, "RX%d", i);
+        lyd_new_term(list1, NULL, "array", buf, 0, NULL);
+        lyd_new_term(list1, NULL, "endpoint-type", "2", 0, NULL);
+
+        if(lyd_new_inner(list1, NULL, "compression", 0, &list2) == LY_SUCCESS)
+        {
+            VRB("RX lyd_new_list success");
+        }
+        else{
+            VRB("lyd_new_list failed -- %s", ly_errmsg(ly_ctx));
+            goto error;
+        }
+        lyd_new_term(list2, NULL, "dynamic-compression-supported", "FALSE", 0, NULL);
+        lyd_new_term(list2, NULL, "realtime-variable-bit-width-supported", "FALSE", 0, NULL);
+    }
+
+    *parent = root;
+    return SR_ERR_OK;
+
+error:
+    printf("#####Exiting uplane oper cb with error######\n");
+    lyd_free_tree(root);
+    return SR_ERR_INTERNAL;
+}
+int
+np2srv_uplane_sllte_oper_cb(sr_session_ctx_t *session, uint32_t UNUSED(sub_id), const char *UNUSED(module_name),
+        const char *UNUSED(path), const char *UNUSED(request_xpath), uint32_t UNUSED(request_id),
+        struct lyd_node **parent, void *UNUSED(private_data))
+{
+    struct lyd_node *root = NULL, *list1,  *list2;
+    const struct lys_module *mod;
+    sr_conn_ctx_t *conn;
+    struct ly_ctx *ly_ctx;
+    char **cpblts;
+    char *time_str, buf[32];
+    uint32_t i;
+
+    /* context is locked while the callback is executed */
+    conn = sr_session_get_connection(session);
+    ly_ctx = (struct ly_ctx *)sr_acquire_context(conn);
+    sr_release_context(conn);
+
+    if(lyd_new_path(NULL, ly_ctx, "/o-ran-uplane-conf:user-plane-configuration", NULL, 0, &root))
+    {
+        goto error;
+    }
+    for( i = 0; i < 4; i++)
+    {
+        sprintf(buf, "STXE%d", i);
+        if(lyd_new_list(root, NULL, "static-low-level-tx-endpoints", 0, &list1, buf) == LY_SUCCESS)
+        {
+            VRB("lyd_new_list success");
+        }
+        else{
+            VRB("lyd_new_list failed -- %s", ly_errmsg(ly_ctx));
+            goto error;
+        }
+        lyd_new_term(list1, NULL, "restricted-interfaces", "ETH1", 0, NULL);
+        sprintf(buf , "TX%d", i);
+        lyd_new_term(list1, NULL, "array", buf, 0, NULL);
+        lyd_new_term(list1, NULL, "endpoint-type", "2", 0, NULL);
+
+        if(lyd_new_inner(list1, NULL, "compression", 0, &list2) == LY_SUCCESS)
+        {
+            VRB("RX lyd_new_list success");
+        }
+        else{
+            VRB("lyd_new_list failed -- %s", ly_errmsg(ly_ctx));
+            goto error;
+        }
+        lyd_new_term(list2, NULL, "dynamic-compression-supported", "FALSE", 0, NULL);
+        lyd_new_term(list2, NULL, "realtime-variable-bit-width-supported", "FALSE", 0, NULL);
+    }
+
+    *parent = root;
+    return SR_ERR_OK;
+
+error:
+    printf("#####Exiting uplane oper cb with error######\n");
+    lyd_free_tree(root);
+    return SR_ERR_INTERNAL;
+}
+int
+np2srv_uplane_rx_arrays_oper_cb(sr_session_ctx_t *session, uint32_t UNUSED(sub_id), const char *UNUSED(module_name),
+        const char *UNUSED(path), const char *UNUSED(request_xpath), uint32_t UNUSED(request_id),
+        struct lyd_node **parent, void *UNUSED(private_data))
+{
+    struct lyd_node *root = NULL, *list1,  *list2;
+    const struct lys_module *mod;
+    sr_conn_ctx_t *conn;
+    struct ly_ctx *ly_ctx;
+    char **cpblts;
+    char *time_str, buf[32];
+    uint32_t i;
+
+    /* context is locked while the callback is executed */
+    conn = sr_session_get_connection(session);
+    ly_ctx = (struct ly_ctx *)sr_acquire_context(conn);
+    sr_release_context(conn);
+
+    if(lyd_new_path(NULL, ly_ctx, "/o-ran-uplane-conf:user-plane-configuration", NULL, 0, &root))
+    {
+        goto error;
+    }
+    for( i = 0; i < 4; i++)
+    {
+        sprintf(buf, "RX%d", i);
+        if(lyd_new_list(root, NULL, "rx-arrays", 0, &list1, buf) == LY_SUCCESS)
+        {
+            VRB("lyd_new_list success");
+        }
+        else{
+            VRB("lyd_new_list failed -- %s", ly_errmsg(ly_ctx));
+            goto error;
+        }
+        lyd_new_term(list1, NULL, "number-of-rows", "2", 0, NULL);
+        lyd_new_term(list1, NULL, "number-of-columns", "2", 0, NULL);
+        lyd_new_term(list1, NULL, "number-of-array-layers", "2", 0, NULL);
+        lyd_new_term(list1, NULL, "vertical-spacing", "123.456", 0, NULL);
+        lyd_new_term(list1, NULL, "horizontal-spacing", "123.456", 0, NULL);
+
+        if(lyd_new_list(list1, NULL, "capabilities", 0, &list2) == LY_SUCCESS)
+        {
+            VRB("RX lyd_new_list success");
+        }
+        else{
+            VRB("lyd_new_list failed -- %s", ly_errmsg(ly_ctx));
+            goto error;
+        }
+        lyd_new_term(list2, NULL, "max-supported-frequency-ul", "6000", 0, NULL);
+        lyd_new_term(list2, NULL, "min-supported-frequency-ul", "300", 0, NULL);
+        lyd_new_term(list2, NULL, "max-supported-bandwidth-ul", "200", 0, NULL);
+        lyd_new_term(list2, NULL, "max-num-carriers-ul", "2", 0, NULL);
+        lyd_new_term(list2, NULL, "max-carrier-bandwidth-ul", "100", 0, NULL);
+        lyd_new_term(list2, NULL, "min-carrier-bandwidth-ul", "5", 0, NULL);
+    }
+
+    #if 0
+    printf("#####Inside uplane oper cb######\n");
+    if (lyd_new_path(NULL, ly_ctx, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/number-of-rows", "2", 0, &root)) {
+        goto error;
+    }
+    VRB("created new path");
+    if(lyd_new_path(root, NULL, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/number-of-columns", "2", 0, NULL) == LY_SUCCESS)
+    //if(1)
+    {
+        VRB("lyd_new_term success");
+    }
+    else{
+        VRB("lyd_new_term failed -- %s", ly_errmsg(ly_ctx));
+        goto error;
+    }
+    lyd_new_path(root, NULL, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/number-of-array-layers", "2", 0, NULL);
+    lyd_new_path(root, NULL, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/vertical-spacing", "123.456", 0, NULL);
+    
+    if(lyd_new_path(root, NULL, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/capabilities/max-supported-frequency-dl","2", 0, &cont) == LY_SUCCESS)
+    {
+        VRB("lyd_new_list success");
+    }
+    else{
+        VRB("lyd_new_list failed -- %s", ly_errmsg(ly_ctx));
+        goto error;
+    }
+    lyd_new_term(root, NULL, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/capabilities/min-supported-frequency-dl","2", 0, NULL);
+    print_xml(root);
+    //print_xml(list);
+    strcpy(buf, "1");
+    //lyd_new_term(list, NULL, "number-of-rows", buf, 0, NULL);
+
+    //lyd_new_term(list, NULL, "data1", "1", 0, NULL);
+    //lyd_new_term(list, NULL, "data2", "2", 0, NULL);
+    printf("#####Exiting uplane oper cb######\n");
+    #endif
+    *parent = root;
+    return SR_ERR_OK;
+
+error:
+    printf("#####Exiting uplane oper cb with error######\n");
+    lyd_free_tree(root);
+    return SR_ERR_INTERNAL;
+}
+int
+np2srv_uplane_tx_arrays_oper_cb(sr_session_ctx_t *session, uint32_t UNUSED(sub_id), const char *UNUSED(module_name),
+        const char *UNUSED(path), const char *UNUSED(request_xpath), uint32_t UNUSED(request_id),
+        struct lyd_node **parent, void *UNUSED(private_data))
+{
+    struct lyd_node *root = NULL, *list1,  *list2;
+    const struct lys_module *mod;
+    sr_conn_ctx_t *conn;
+    struct ly_ctx *ly_ctx;
+    char **cpblts;
+    char *time_str, buf[32];
+    uint32_t i;
+
+    /* context is locked while the callback is executed */
+    conn = sr_session_get_connection(session);
+    ly_ctx = (struct ly_ctx *)sr_acquire_context(conn);
+    sr_release_context(conn);
+
+    if(lyd_new_path(NULL, ly_ctx, "/o-ran-uplane-conf:user-plane-configuration", NULL, 0, &root))
+    {
+        goto error;
+    }
+    for( i = 0; i < 4; i++)
+    {
+        sprintf(buf, "TX%d", i);
+        if(lyd_new_list(root, NULL, "tx-arrays", 0, &list1, buf) == LY_SUCCESS)
+        {
+            VRB("lyd_new_list success");
+        }
+        else{
+            VRB("lyd_new_list failed -- %s", ly_errmsg(ly_ctx));
+            goto error;
+        }
+        lyd_new_term(list1, NULL, "number-of-rows", "2", 0, NULL);
+        lyd_new_term(list1, NULL, "number-of-columns", "2", 0, NULL);
+        lyd_new_term(list1, NULL, "number-of-array-layers", "2", 0, NULL);
+        lyd_new_term(list1, NULL, "vertical-spacing", "123.456", 0, NULL);
+        lyd_new_term(list1, NULL, "horizontal-spacing", "123.456", 0, NULL);
+        
+        if(lyd_new_list(list1, NULL, "capabilities", 0, &list2) == LY_SUCCESS)
+        {
+            VRB("lyd_new_list success");
+        }
+        else{
+            VRB("lyd_new_list failed -- %s", ly_errmsg(ly_ctx));
+            goto error;
+        }
+        lyd_new_term(list2, NULL, "max-supported-frequency-dl", "6000", 0, NULL);
+        lyd_new_term(list2, NULL, "min-supported-frequency-dl", "300", 0, NULL);
+        lyd_new_term(list2, NULL, "max-supported-bandwidth-dl", "200", 0, NULL);
+        lyd_new_term(list2, NULL, "max-num-carriers-dl", "2", 0, NULL);
+        lyd_new_term(list2, NULL, "max-carrier-bandwidth-dl", "100", 0, NULL);
+        lyd_new_term(list2, NULL, "min-carrier-bandwidth-dl", "5", 0, NULL);
+    }
+    #if 0
+    printf("#####Inside uplane oper cb######\n");
+    if (lyd_new_path(NULL, ly_ctx, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/number-of-rows", "2", 0, &root)) {
+        goto error;
+    }
+    VRB("created new path");
+    if(lyd_new_path(root, NULL, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/number-of-columns", "2", 0, NULL) == LY_SUCCESS)
+    //if(1)
+    {
+        VRB("lyd_new_term success");
+    }
+    else{
+        VRB("lyd_new_term failed -- %s", ly_errmsg(ly_ctx));
+        goto error;
+    }
+    lyd_new_path(root, NULL, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/number-of-array-layers", "2", 0, NULL);
+    lyd_new_path(root, NULL, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/vertical-spacing", "123.456", 0, NULL);
+    
+    if(lyd_new_path(root, NULL, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/capabilities/max-supported-frequency-dl","2", 0, &cont) == LY_SUCCESS)
+    {
+        VRB("lyd_new_list success");
+    }
+    else{
+        VRB("lyd_new_list failed -- %s", ly_errmsg(ly_ctx));
+        goto error;
+    }
+    lyd_new_term(root, NULL, "/o-ran-uplane-conf:user-plane-configuration/tx-arrays[name='TX1']/capabilities/min-supported-frequency-dl","2", 0, NULL);
+    print_xml(root);
+    //print_xml(list);
+    strcpy(buf, "1");
+    //lyd_new_term(list, NULL, "number-of-rows", buf, 0, NULL);
+
+    //lyd_new_term(list, NULL, "data1", "1", 0, NULL);
+    //lyd_new_term(list, NULL, "data2", "2", 0, NULL);
+    printf("#####Exiting uplane oper cb######\n");
+    #endif
+    *parent = root;
+    return SR_ERR_OK;
+
+error:
+    printf("#####Exiting uplane oper cb with error######\n");
+    lyd_free_tree(root);
+    return SR_ERR_INTERNAL;
+}
 int
 np2srv_ncm_oper_cb(sr_session_ctx_t *session, uint32_t UNUSED(sub_id), const char *UNUSED(module_name),
         const char *UNUSED(path), const char *UNUSED(request_xpath), uint32_t UNUSED(request_id),
diff -urN netopeer2/src/netconf_monitoring.h netopeer2-working/src/netconf_monitoring.h
--- netopeer2/src/netconf_monitoring.h	2024-02-09 22:03:28.048421897 +0530
+++ netopeer2-working/src/netconf_monitoring.h	2024-02-10 13:40:30.414412713 +0530
@@ -64,4 +64,26 @@
 int np2srv_rpc_getschema_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *op_path, const struct lyd_node *input,
         sr_event_t event, uint32_t request_id, struct lyd_node *output, void *private_data);
 
+int np2srv_uplane_tx_arrays_oper_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *path,
+        const char *request_xpath, uint32_t request_id, struct lyd_node **parent, void *private_data);
+int np2srv_uplane_rx_arrays_oper_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *path,
+        const char *request_xpath, uint32_t request_id, struct lyd_node **parent, void *private_data);
+int np2srv_uplane_sllte_oper_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *path,
+        const char *request_xpath, uint32_t request_id, struct lyd_node **parent, void *private_data);
+int np2srv_uplane_sllre_oper_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *path,
+        const char *request_xpath, uint32_t request_id, struct lyd_node **parent, void *private_data);
+int np2srv_uplane_txac_oper_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *path,
+        const char *request_xpath, uint32_t request_id, struct lyd_node **parent, void *private_data);
+int np2srv_uplane_txac_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data);
+int np2srv_uplane_rxac_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data);
+int np2srv_uplane_lltxe_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data);
+int np2srv_uplane_llrxe_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data);
+int np2srv_uplane_lltxl_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data);
+int np2srv_uplane_llrxl_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath, 
+        sr_event_t event, uint32_t request_id, void *private_data);
 #endif /* NP2SRV_NETCONF_MONITORING_H_ */
